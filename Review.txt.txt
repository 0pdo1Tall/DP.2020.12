Phân công công việc tìm Coupling: Thọ tìm trong Entity, Tiến tìm trong DAO + Subsystem, Thao tìm trong Entity

// Review Code ở đây(Ghi rõ tên người review)

+ Reviewer: Le Anh Thanh

/src/main/java/entity/media/ gồm các file Book.java, CD.java, DVD.java, Media.java
/src/main/java/entity/order/ có file Order.java
/src/main/java/entity/payment/ có file Credit.java
/src/main/java/entity/shipping/ có file DeliveryInfo.java

Toàn bộ các thuộc tính được khai báo ở đầu của lớp đều không phải là Common coupling, vì đó là thuộc tính của riêng từng đối tượng trong lớp chứ không phải là dữ liệu hoặc là cấu trúc dữ liệu toàn cục, và vì thế không có module nào cùng chia sẻ những thuộc tính này.



// Phân công công việc tìm Cohesion: Thọ tìm trong Entity, Tiến tìm trong DAO + Subsystem, Thao tìm trong Entity

// Review Code ở đây(Ghi rõ tên người review)

+ Reviewer: Le Anh Thanh

/src/main/java/entity/cart/ gồm các file Cart.java, CartItem.java
/src/main/java/entity/db/ có file AIMSDB.java
/src/main/java/entity/invoice/ có file Invoice.java
/src/main/java/entity/media/ gồm các file Book.java, DVD.java, Media.java
/src/main/java/entity/order/ có file Order.java
/src/main/java/entity/shipping/ có file DeliveryInfo.java

Tất cả các class trong này đều không phải là Communicational cohesion, vì mặc dù các phương thức sử dụng chung dữ liệu, nhưng chúng đều nhằm mục đích cung cấp các chức năng cần thiết cho hoạt động của lớp đó.

/src/main/java/entity/cart/Cart.java
Class này có phương thức checkAvailabilityOfProduct(), không thuộc nghiệp vụ của giỏ hàng, khi còn trực tiếp truy cập vào database
Phương thức này nên chuyển giao cho lớp khác --> Coincidental cohesion

/src/main/java/entity/media/Book.java
Các phương thức get, set là cần thiết --> không phải là Coincidental cohesion

/src/main/java/entity/order/Order.java
Các phương thức thực hiện tác vụ cho lớp Order --> không phải là Logical cohesion, vì logical cohesion phải là thực hiện cùng một loại nhiệm vụ nhưng cách thức xử lý khác xa nhau.




// Phân công công việc tìm vi phạm nguyên lý S.O.L.I.D: Thọ tìm trong Entity, Tiến tìm trong DAO + Subsystem, Thao tìm trong Entity

// Review Code ở đây(Ghi rõ tên người review)

+ Reviewer: Le Anh Thanh

/src/main/java/entity/payment/PaymentTransaction.java
Khi có loại Card mới thì phải sửa --> Chính xác, nhưng như thế là vi phạm OCP chứ không phải DIP
Tất nhiên phương thức này cũng vi phạm DIP, nhưng bởi vì nó phụ thuộc vào một lớp cài đặt cụ thể là CreditCard chứ không phải là một abstract class đại diện cho mọi phương tiện thanh toán.

/src/main/java/entity/shipping/DeliveryInfo.java
Phụ thuộc vào DistanceCalculator --> vi phạm S.O.L.I.D --> chính xác. Nhưng không phải vi phạm OCP mà là vi phạm DIP
Tất nhiên class này cũng vi phạm OCP, vì nếu mở rộng theo yêu cầu, ta sẽ phải đổi phương thức tính khoảng cách khác, và như thế phải modify lại phần mã nguồn của class này. Do đó class cũng vi phạm OCP.

/src/main/java/entity/order/Order.java 
Vi phạm DIP và OCP do phụ thuộc class Card --> Không có phụ thuộc lớp Card, khả năng ý là phụ thuộc vào lớp Cart. Kể cả thế, việc phụ thuộc vào lớp Cart cũng không dẫn tới OCP vì chúng ta không có nhu cầu mở rộng Cart, và khi mở rộng Cart thì cũng không cần sửa class Order này. DIP thì cần xem xét một chút.
Không hề vi phạm OCP khi kết nối với deliveryInfo, lời giải thích tương tự với Cart.

/src/main/java/entity/media/Media.java
Vi phạm OCP do phụ thuộc MediaDAO() --> Không đúng, bản thân MediaDAO cũng là một lớp bậc cao, và có tính trừu tượng rồi, và có các lớp BookDAO, DVDDAO, CDDAO là các lớp cụ thể kế thừa lớp MediaDAO nên khi có yêu cầu mới hoàn toàn không cần sửa code cũ, mà chỉ cần tạo một lớp mới kế thừa MediaDAO là đủ. 

Nếu có gì sai sót thì hãy phản hồi.
